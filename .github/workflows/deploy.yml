name: Pace Project CI/CD # 워크플로우 이름 설정

on:
  push:
    branches: [ "develop" ] # 해당 브랜치에 코드가 push될 때만 실행

jobs:
  deploy:
    runs-on: ubuntu-latest # 깃허브가 제공하는 최신 우분투 가상 환경에서 작업

    steps:
      - name: Checkout code
        uses: actions/checkout@v4 # 깃허브 서버로 내 소스 코드를 가져옴

      - name: Login to Docker Hub
        uses: docker/login-action@v3 # 도커 허브 접속 시도
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }} # 깃허브 시크릿에서 아이디 가져옴
          password: ${{ secrets.DOCKERHUB_TOKEN }} # 깃허브 시크릿에서 토큰 가져옴

      - name: Build and push Docker image
        uses: docker/build-push-action@v5 # 도커 이미지 빌드 및 전송
        with:
          context: . # 현재 위치의 파일을 바탕으로 빌드
          push: true # 빌드 성공 시 도커 허브로 즉시 보냄
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/pace-project:latest # 이미지 이름과 태그 붙임

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.3 # SSH를 통해 AWS EC2 서버에 접속
        with:
          host: ${{ secrets.EC2_HOST }} # EC2의 IP 주소로 연결
          username: ${{ secrets.EC2_USERNAME }} # 접속 계정(보통 ubuntu) 사용
          key: ${{ secrets.EC2_SSH_KEY }} # .pem 키 내용으로 인증
          script: | # 접속 후 실행할 명령어들 시작
            mkdir -p ~/pace-project # 프로젝트 폴더가 없으면 생성
            cd ~/pace-project # 해당 폴더로 이동
            
            # docker-compose.yml 파일을 서버에 직접 생성
            cat <<EOF > docker-compose.yml
            services:
              # 데이터베이스 서비스 (MySQL)
              pace-db:
                image: mysql:8.0
                container_name: pace-db
                restart: always
                environment:
                  # .env 파일에서 변수를 읽어와 보안을 유지
                  MYSQL_ROOT_PASSWORD: \${MYSQL_ROOT_PASSWORD}
                  MYSQL_DATABASE: \${MYSQL_DATABASE}
                  MYSQL_USER: \${MYSQL_USER}
                  MYSQL_PASSWORD: \${MYSQL_PASSWORD}
                  TZ: Asia/Seoul
                # 한글 및 이모지 지원을 위한 설정
                command: >
                  --character-set-server=utf8mb4
                  --collation-server=utf8mb4_unicode_ci
                ports:
                  - "3306:3306"
                # 컨테이너가 삭제되어도 데이터가 보존되도록 볼륨을 설정
                volumes:
                  - mysql_data:/var/lib/mysql
                networks:
                  - pace-network
            
              # Spring Boot
              pace-app:
                # 현재 경로의 Dockerfile을 기반으로 이미지를 빌드
                image: ${{ secrets.DOCKERHUB_USERNAME }}/pace-project:latest
                container_name: pace-app
                restart: always
                # DB 컨테이너가 먼저 실행된 후 애플리케이션이 실행되도록 순서를 보장
                depends_on:
                  - pace-db
                environment:
                  # DB 접속 주소에 서비스 이름(pace-db)을 사용하여 내부 통신을 수행
                  SPRING_DATASOURCE_URL: jdbc:mysql://pace-db:3306/\${MYSQL_DATABASE}?serverTimezone=Asia/Seoul&characterEncoding=UTF-8
                  SPRING_DATASOURCE_USERNAME: \${MYSQL_USER}
                  SPRING_DATASOURCE_PASSWORD: \${MYSQL_PASSWORD}
                  SPRING_PROFILES_ACTIVE: prod
                ports:
                  - "8080:8080"
                networks:
                  - pace-network
            
            # 서비스들이 서로 소통할 수 있는 가상 네트워크 정의
            networks:
              pace-network:
                driver: bridge
            
            # 데이터 보존을 위한 명명된 볼륨 정의
            volumes:
              mysql_data:
            EOF
            
            docker-compose down || true # 기존 컨테이너 끔 (없어도 에러 무시하고 넘어감)
            
            docker pull ${{ secrets.DOCKERHUB_USERNAME }}/pace-project:latest # 창고에서 새 이미지 가져옴
            
            # 서버에서 사용할 비밀 장부(.env)를 시크릿 값으로 새로 만듦
            echo "MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}" > .env
            echo "MYSQL_DATABASE=${{ secrets.MYSQL_DATABASE }}" >> .env
            echo "MYSQL_USER=${{ secrets.MYSQL_USER }}" >> .env
            echo "MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}" >> .env
            
            docker-compose up -d # 새 이미지로 세트 메뉴(DB+앱) 다시 실행
            
            # 헬스 체크: 서버가 제대로 떴는지 10번 확인함
            echo "Starting health check..."
            for i in {1..10}; do
              RESPONSE=$(curl -s http://localhost:8080/health) # 내 서버에 안부를 물어봄
              if [ "$RESPONSE" = "OK" ]; then # 대답이 "OK"면 성공
                echo "Health check passed!"
                exit 0
              fi
              echo "Waiting for server... ($i/10)" # 아직 안 떴으면 10초 기다림
              sleep 10
            done
            echo "Health check failed." # 10번 다 실패하면 배포 실패 처리
            exit 1